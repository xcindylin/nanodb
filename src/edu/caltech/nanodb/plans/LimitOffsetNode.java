package edu.caltech.nanodb.plans;


import edu.caltech.nanodb.expressions.OrderByExpression;
import edu.caltech.nanodb.expressions.TupleLiteral;
import edu.caltech.nanodb.qeval.PlanCost;
import edu.caltech.nanodb.relations.Tuple;
import org.apache.log4j.Logger;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;


/**
 * This plan node provides a simple in-memory sort operation for use in
 * LIMIT and OFFSET clauses.
 */
public class LimitOffsetNode extends PlanNode {
    /** A logging object for reporting anything interesting that happens. */
    private static Logger logger = Logger.getLogger(LimitOffsetNode.class);

    /**
     * This array receives all tuples from the child plan node, and then they
     * are sorted and passed along to the parent from this array.
     */
    private ArrayList<Tuple> limitedResults;

    /** The index of the current tuple in the sorted results. */
    private int currentTupleIndex;

    /**
     * A flag indicating whether the sort node has generate all of its output or not.
     */
    private boolean done;

    /**
     * Number of tuples that we will output.
     */
    private int limit;

    /**
     * The offset designated for the number of tuples we output.
     * Ex: LIMIT 5 OFFSET 5 will output tuples 5 through 10
     */
    private int offset;

    /**
     * Constructs a PlanNode with a given operation type.  This method will be
     * called by subclass constructors.
     *
     * @param subplan the subplan that produces the results to sort
     * @param limit a specification of how many tuples the result should output
     * @param offset a specification of which tuples the result should output
     */
    public LimitOffsetNode(PlanNode subplan, int limit, int offset) {
        super(OperationType.SORT, subplan);

        if (limit < 0 || offset < 0)
            throw new IllegalArgumentException("limit and offset must be" +
            "nonnegative");

        this.limit = limit;
        this.offset = offset;
    }


    /**
     * This node's results are sorted if its subplan produces sorted results.
     */
    public List<OrderByExpression> resultsOrderedBy() {
        return leftChild.resultsOrderedBy();
    }


    /** The limit offset plan-node doesn't support marking. */
    public boolean supportsMarking() {
        return false;
    }


    /**
     * The limit offset plan-node doesn't require marking from either of its children.
     */
    public boolean requiresLeftMarking() {
        return false;
    }


    /**
     * The sort plan-node doesn't require marking from either of its children.
     */
    public boolean requiresRightMarking() {
        return false;
    }


    /**
     * The sort plan-node produces the same schema as its child plan-node, so
     * this method simply caches the subplan's schema object.
     */
    public void prepare() {
        // Need to prepare the left child-node before we can do our own work.
        leftChild.prepare();

        // Grab the schema and column-statistics from the left child.
        schema = leftChild.getSchema();
        stats = leftChild.getStats();

        // Grab the left child's cost, then update the cost based on the cost
        // of sorting.

        PlanCost childCost = leftChild.getCost();
        if (childCost != null) {
            cost = new PlanCost(childCost);

            // Sublist in memory is an N operation
            cost.cpuCost += cost.numTuples;
        }
        else {
            logger.info(
                "Child's cost not available; not computing this node's cost.");
        }
    }


    /**
     * Does any initialization the node might need.  This could include
     * resetting state variables or starting the node over from the beginning.
     *
     */
    public void initialize() {
        super.initialize();

        limitedResults = null;
        done = false;

        leftChild.initialize();
    }


    /**
     * Gets the next tuple that fulfills the conditions for this plan node.
     * If the node has a child, it should call getNextTuple() on the child.
     * If the node is a leaf, the tuple comes from some external source such
     * as a table file, the network, etc.
     *
     * @return the next tuple to be generated by this plan, or <tt>null</tt>
     *         if the plan has finished generating plan nodes.
     *
     * @throws java.io.IOException if table data cannot be read from the filesystem
     * @throws IllegalStateException if a plan node is not properly initialized
     */
    public Tuple getNextTuple() throws IllegalStateException, IOException {
        // If we gone through all the tuples, we will return null
        if (done)
            return null;

        // If the limitedResults hasn't been filled yet, we should process them
        if (limitedResults == null) {
            prepareLimitedResults();
        }

        // Get the next tuple, if we have gotten all the tuples then set flag
        // to notify that we're done
        Tuple tup = null;
        if (currentTupleIndex < limitedResults.size()) {
            tup = limitedResults.get(currentTupleIndex);
            currentTupleIndex++;
        }
        else {
            done = true;
        }

        return tup;
    }

    // Fills the limited results with the subplan's results, but limited to
    // the limit and offset specified by user
    private void prepareLimitedResults() throws IOException {
        limitedResults = new ArrayList<Tuple>();
        while (true) {
            // Get the next tuple.  If it's not cacheable then make a copy of it
            // before storing it away.
            Tuple tup = leftChild.getNextTuple();
            if (tup == null)
                break;

            if (!tup.isDiskBacked())
                tup = new TupleLiteral(tup);

            limitedResults.add(tup);
        }

        // Shift by offset
        int startIndex = offset;
        // If offset is over the amount we have, then we have zero tuples
        if (startIndex >= limitedResults.size()) {
            logger.warn("Offset of " + offset + " goes past the number of" +
            " tuples in result");
            limitedResults.clear();
        }
        // Otherwise calculate the range of values, note that we can't go
        // past the end of the number of tuples
        else {
            int endIndex = startIndex + limit;
            endIndex = Math.min(endIndex, limitedResults.size());
            limitedResults = new
                    ArrayList<Tuple>(limitedResults.subList(startIndex, endIndex));
        }

        currentTupleIndex = 0;
    }


    /** The limit offset plan-node doesn't support marking. */
    public void markCurrentPosition() {
        throw new UnsupportedOperationException(
            "limit offset plan-node doesn't support marking.");
    }


    /** The limit offset plan-node doesn't support marking. */
    public void resetToLastMark() {
        throw new UnsupportedOperationException(
            "limit offset plan-node doesn't support marking.");
    }


    /** Clean up after evaluation of the limit offset plan-node. */
    public void cleanUp() {
        // Allow this collection to be garbage-collected.
        limitedResults = null;

        leftChild.cleanUp();
    }


    @Override
    public String toString() {
        return "Limit [" + limit + "] Offset [" + offset + "]";
    }


    /**
     * Checks if the argument is a plan node tree with the same structure,
     * but not necesarily the same references.
     *
     * @param obj the object to which we are comparing
     *
     * @design We re-declare this here to force its implementation in subclasses.
     */
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof LimitOffsetNode) {
            LimitOffsetNode other = (LimitOffsetNode) obj;

            return limit == other.limit &&
                   offset == other.offset &&
                   leftChild.equals(other.leftChild);
        }
        return false;
    }


    /**
     * Computes the hash-code of a plan-node, including any sub-plans of this
     * plan.  This method is used to see if two plan nodes (or subtrees)
     * <em>might be</em> equal.
     *
     * @return the hash code for the plan node and any subnodes it may contain.
     */
    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + limit;
        hash = 31 * hash + offset;
        hash = 31 * hash + leftChild.hashCode();
        return hash;
    }
}
